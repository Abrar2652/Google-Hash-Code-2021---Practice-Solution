# -*- coding: utf-8 -*-
"""Google Hash Code Solution - A.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pkIMJ3v05Hm26NyhNqXkrpws3N-GoNMJ
"""

import pandas as pd
d_path = "a.txt"
with open(d_path, 'r') as reader:
    a = reader.readlines()
 
no_integers = [x for x in a[1:] if not isinstance(x, int)]
no_integers

"""# New Section"""

d_path = "a.txt"
d_path=open(d_path, 'r')
u = d_path.read().replace('\n','\n')
u=u.split()
u

ing=[]
for x in u:
    if not x.isdigit():
        ing.append(x)
ing

digits = [int(elem) for elem in u[4:] if elem.isdigit()]
print(digits)

new2=[]
y=0
for x in digits:
    new=[]
    for i in range(0,x):
        new.append(ing[y])
        y=y+1
    new2.append(new)        
new2

pizzas_num = int(u[0])
print(pizzas_num)

for x in new2:
    print(x)

dic={pizza:new2[pizza] for pizza in range(0,pizzas_num)}
dic

dic[0]

t2=int(u[1])
t3=int(u[2])
t4=int(u[3])
type(int(t4))

# Function to create combinations  
# without itertools 

def combinations_fnc(lst, n): 
      
    if n == 0: 
        return [[]] 
      
    l =[] 
    for i in range(0, len(lst)): 
          
        m = lst[i] 
        remLst = lst[i + 1:] 
          
        for p in combinations_fnc(remLst, n-1): 
            l.append([m]+p) 
              
    return l

import itertools

pizzas=list(range(0,pizzas_num))
print(pizzas)
comb_t2=combinations_fnc(pizzas,2)
comb_t3=combinations_fnc(pizzas,3)
comb_t4=combinations_fnc(pizzas,4)
#comb_t2=[item for item in itertools.combinations(pizzas,2)]
#comb_t3=[item for item in itertools.combinations(pizzas,3)]
#comb_t4=[item for item in itertools.combinations(pizzas,4)]

import itertools
from itertools import combinations
test_list=range(0,500)
i,j=2,4
res=[]
for sub in range(j):
    if sub >= (i-1):
        res.extend(combinations(test_list,sub+1))
print(res)

total=comb_t2 + comb_t3 + comb_t4
total

def allUnique(x):
        seen = list()
        return not any(i in seen or seen.append(i) for i in x)

from itertools import combinations

#len([item for item in itertools.combinations(total,2)])

m=[]
for i,j in [item for item in itertools.combinations(total,2)]: 
    if allUnique(i+j)==True:
        m.append([i,j])

m

n=[]
for i,j in m:
    if(len(i)+len(j)<=pizzas_num)==True:
        n.append([i,j])

n

#all unique possible combinations taking 
for i,j in n:
    print(i,j)

temp2=[]
z=[]
for i,j in n:
    temp=[]
    z=[]
    for x in i: 
        z=z+dic[x]
        temp.append(z) 
    temp2.append(z)
temp2

import numpy as np
words=['onion', 'pepper', 'olive', 'chicken', 'mushroom', 'pepper']
len(np.unique(words))

for x in temp2:
    print(len(np.unique(x)))

col1=[]
for x in temp2:
    col1.append(len(np.unique(x)))
len(col1)

temp3=[]
z=[]
for i,j in n:
    temp=[]
    z=[]
    for x in j: 
        z=z+dic[x]
        temp.append(z) 
    temp3.append(z)
temp3

col2=[]
for x in temp3:
    col2.append(len(np.unique(x)))
(col2)

final_list = [] 

# Choose the smaller list to iterate
list_to_iterate = len(col1) < len(col2) and col1 or col2

for i in range(0, len(list_to_iterate)): 
    final_list.append(pow(col1[i],2) +pow(col2[i],2)) 
final_list
#list_to_iterate

#indices of the max value
m = max(final_list)
indices=[i for i, j in enumerate(final_list) if j == m]
indices

x=[]
for i in indices:
    x.append(n[i])
print(x[0])

print(len(x[0][0]))

print(len(x[0]))
for i in x[0]:
  print(len(i),end=" ")
  for j in i:
    print(j, end=" ")
  print()

